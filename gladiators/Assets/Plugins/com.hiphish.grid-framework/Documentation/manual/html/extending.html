<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<title>Grid Framework: Extending Grid Framework</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js.txt"></script>
<script type="text/javascript" src="dynsections.js.txt"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js.txt"></script>
<script type="text/javascript" src="navtreedata.js.txt"></script>
<script type="text/javascript" src="navtree.js.txt"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js.txt"></script>
<script type="text/javascript" src="search/search.js.txt"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grid Framework
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Easy grid setup and scripting for Unity 3D</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js.txt"></script>
<script type="text/javascript" src="menu.js.txt"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('extending.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Extending Grid Framework </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_manual_extending"></a> Grid Framework, much like Unity3D itself, is written as a multi-purpose framework. You can write your own code and reference Grid Framework's API just as you would reference the Unity3D API, but sometimes you might find yourself wanting not just to use Grid Framework, but to expand upon it. Maybe there is some method or variable that would fit greatly in your project but that is too specific for me to include by default.</p>
<p >I strongly advise against changing the source code of Grid Framework, you will either have to re-apply your changes after each update or refrain from updating and thus miss bug fixes and other improvements. Instead, you should use inheritance or extension methods.</p>
<dl class="section note"><dt>Note</dt><dd>The core code of Grid Framework is contained in its own assemblies: <code>com.hiphish.grid-framework.Runtime</code> for the core logic, <code>com.hiphish.grid-framework.Editor</code> for editor scripts. These assemblies are referenced automatically by the default Unity3D assemblies, but you will have to reference them explicitly in your own assemblies.</dd></dl>
<h1>Extension Methods</h1>
<p ><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods">Extension methods</a> are a way to add methods to existing classes without having or needing access to the implementation of the class. Once a method has been added this way it will be treated the same way as other methods and it will even show up in auto completion if your editor supports it.</p>
<p >Grid Framework ships with a number of official extension methods for its grids. The criteria for deciding whether a method should be a class member or an extension are:</p>
<ul>
<li>Is the method a part of the responsibility of the class? If the class is a grid, then is the method something you would expect a grid to do or something you would want to do <em>with</em> a grid?</li>
<li>Can the method be efficiently implemented using the grid's public members? If yes, then there is no need for it to be a member of the grid.</li>
</ul>
<p >Let us take a look at how an extension method can be written. The following is an excerpt of how <code>NearestVertex</code> for rectangular grids is implemented.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> UnityEngine;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Name aliases for easier writing</span></div>
<div class="line"><span class="keyword">using</span> RectGrid = <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_grids.html">Grids</a>.<a class="code hl_class" href="class_grid_framework_1_1_grids_1_1_rect_grid.html">RectGrid</a>;</div>
<div class="line"><span class="keyword">using</span> CSystem = <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_grids.html">Grids</a>.<a class="code hl_class" href="class_grid_framework_1_1_grids_1_1_rect_grid.html">RectGrid</a>.CoordinateSystem;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extension methods are namespaced to separate them from the rest of the API</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespace_grid_framework_1_1_extensions_1_1_nearest.html">GridFramework.Extensions.Nearest</a> {</div>
<div class="line">    <span class="comment">// The name of the class is arbitrary</span></div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class </span>Rectangular {</div>
<div class="line">        <span class="comment">// Signature of an extension method, note the first parameter</span></div>
<div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Vector3 NearestVertex(<span class="keyword">this</span> RectGrid grid, Vector3 point, CSystem system) {</div>
<div class="line">            var gridPoint    = grid.WorldToGrid(point);</div>
<div class="line">            var roundedPoint = RoundVector3(gridPoint);</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">return</span> system == CSystem.Grid ? roundedPoint : grid.GridToWorld(roundedPoint);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This helper method is not an extension method</span></div>
<div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Vector3 RoundVector3(Vector3 point) {</div>
<div class="line">            <span class="keywordflow">for</span> (var i = 0; i &lt; 3; ++i) {</div>
<div class="line">                point[i] = Mathf.Round(point[i]);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> point;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_grid_framework_1_1_grids_1_1_rect_grid_html"><div class="ttname"><a href="class_grid_framework_1_1_grids_1_1_rect_grid.html">GridFramework.Grids.RectGrid</a></div><div class="ttdoc">A standard three-dimensional rectangular grid.</div><div class="ttdef"><b>Definition:</b> RectGrid.cs:16</div></div>
<div class="ttc" id="anamespace_grid_framework_1_1_extensions_1_1_nearest_html"><div class="ttname"><a href="namespace_grid_framework_1_1_extensions_1_1_nearest.html">GridFramework.Extensions.Nearest</a></div><div class="ttdef"><b>Definition:</b> Nearest/Hexagonal.cs:4</div></div>
<div class="ttc" id="anamespace_grid_framework_1_1_grids_html"><div class="ttname"><a href="namespace_grid_framework_1_1_grids.html">GridFramework.Grids</a></div><div class="ttdef"><b>Definition:</b> BaseGrid.cs:7</div></div>
<div class="ttc" id="anamespace_grid_framework_html"><div class="ttname"><a href="namespace_grid_framework.html">GridFramework</a></div><div class="ttdef"><b>Definition:</b> HexGridEditor.cs:5</div></div>
</div><!-- fragment --><p >The extension method is namespaced, so you have to import it explicitly, but that is optional. The extension method is a method of a static class and as such it has access to all member of it (such as <code>RoundVector3</code>). The names of the class and the methods are not important. What matters is the first argument of the method, it consists of <code>this</code>, followed by the class to extend (<code>RectGrid</code> in this case) and finally an identifier of our own choice. The remaining arguments are the arguments of the resulting extension method. You can now call the extension method like any other method of the grid.</p>
<div class="fragment"><div class="line">RectGrid grid;</div>
<div class="line">Vector3 point;</div>
<div class="line"> </div>
<div class="line">var nearest = grid.NearestVertex(point, RectGrid.CoordinateSystem.World);</div>
</div><!-- fragment --><h1>Writing your own grid</h1>
<p >All grids inherit from the abstract <code>BaseGrid</code> class and you can write your own grids by inheriting from it an implementing all its abstract methods. For information on what exactly and how to implement it please consult the scripting reference of <code>BaseGrid</code>.</p>
<p >Here is what a very basic implementation of <code>RectGrid</code> could look like if we remove some of its functionality.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> UnityEngine;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_grids.html">Grids</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>CustomGridFramework.Grids {</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">class </span>RectGrid: BaseGrid {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Private fields</span></div>
<div class="line">        [SerializeField]</div>
<div class="line">        <span class="keyword">private</span> Vector3 _spacing = Vector3.one;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Privately used caches</span></div>
<div class="line">        <span class="keyword">private</span> Matrix4x4 _worldToGridMatrix;</div>
<div class="line">        <span class="keyword">private</span> Matrix4x4 _gridToWorldMatrix;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Public accessors</span></div>
<div class="line">        <span class="keyword">public</span> Vector3 Spacing {</div>
<div class="line">            <span class="keyword">get</span> {</div>
<div class="line">                <span class="keywordflow">return</span> _spacing;</div>
<div class="line">            } <span class="keyword">set</span> {</div>
<div class="line">                _spacing = value;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Implementing abstract methods</span></div>
<div class="line">        <span class="keyword">protected</span> <span class="keyword">override</span> <span class="keywordtype">void</span> UpdateCachedMembers() {</div>
<div class="line">            var rectMatrix  = Matrix4x4.TRS(transform.position, transform.rotation, Vector3.one);</div>
<div class="line">            var scaleMatrix = Matrix4x4.TRS(Vector3.zero, Quaternion.identity, Spacing);</div>
<div class="line"> </div>
<div class="line">            _gridToWorldMatrix = rectMatrix * scaleMatrix;</div>
<div class="line">            _worldToGridMatrix = _gwMatrix.inverse;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Public methods of the grid</span></div>
<div class="line">        <span class="keyword">public</span> Vector3 WorldToGrid(Vector3 world) {</div>
<div class="line">            UpdateCachedMembers();</div>
<div class="line">            <span class="keywordflow">return</span> _worldToGridMatrix.MultiplyPoint3x4(world);</div>
<div class="line">        }</div>
<div class="line">        <span class="keyword">public</span> Vector3 GridToWorld(Vector3 grid) {</div>
<div class="line">            UpdateCachedMembers();</div>
<div class="line">            <span class="keywordflow">return</span> _gridToWorldMatrix.MultiplyPoint3x4(grid);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >The new grid class is namespaced to prevent name collision with the existing <code>RectGrid</code> class. It inherits from <code>BaseGrid</code> and overrides one method (<code>UpdateCachedMembers</code>). This grid exposes one property and two methods and has two cached variables in the background.</p>
<p >The purpose of the cache is allow the grid to be lazy: the grid might change its spacing and position many times before a coordinate conversion is actually needed and it would be a waste of resources to compute the matrices when they are not needed. Similarly, it would be a waste of time to re-compute the matrix every time we want to convert coordinates even when the grid has not changed.</p>
<p >This kind of lazy evaluation is not necessary, but it makes sense in general and the interface is there if you need it. <code>UpdateCachedMembers</code> should be called before performing coordinate conversion or any other kind of operation that relies on cached members.</p>
<h2>The inspector for your grid</h2>
<p >You do not have to write a custom inspector if the default one generated by Unity3D is good enough for you. Otherwise you will have to implement your own inspector as well. You can inherit the <code>GridInspector</code> class for that purpose, but it is not strictly necessary because grids have no public properties in common. This may or may not change in the future, I have no concrete plans for now. To be on the safe side your inspector should inherit from <code>GridInspector</code>.</p>
<p >Here is a custom inspector to go along with our newly created grid:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> UnityEngine;</div>
<div class="line"><span class="keyword">using</span> UnityEditor;</div>
<div class="line"><span class="keyword">using</span> CustomGridFramework.Grids;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> GridEditor = <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_editor.html">Editor</a>.GridEditor;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>CustomGridFramework.Editor {</div>
<div class="line">    [CustomEditor (typeof(RectGrid))]</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">class </span>RectGridEditor : GridEditor {</div>
<div class="line">        <span class="keyword">protected</span> <span class="keyword">override</span> <span class="keywordtype">void</span> PropertyFields() {</div>
<div class="line">            var _grid = target as RectGrid;</div>
<div class="line">            _grid.Spacing = EditorGUILayout.Vector3Field(<span class="stringliteral">&quot;Spacing&quot;</span>, _grid.Spacing);</div>
<div class="line">            serializedObject.ApplyModifiedProperties();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_grid_framework_1_1_editor_html"><div class="ttname"><a href="namespace_grid_framework_1_1_editor.html">GridFramework.Editor</a></div><div class="ttdef"><b>Definition:</b> HexGridEditor.cs:5</div></div>
</div><!-- fragment --><p >There is only one abstract method to override: <code>PropertyFields</code>. This method displays the fields for all the grid-specific properties.</p>
<h1>Writing your own renderer</h1>
<p >Writing renderers is the same as writing grids: you inherit the base class for renderers and implement all of its abstract methods. If you want to write a renderer for a custom grid of yours you need to inherit from the abstract class <code>GridRenderer</code>, otherwise inherit from one of its grid-specific subclasses <code>RectangularRenderer</code>, <code>SphericalRenderer</code>, <code>HexagonalRenderer</code> and <code>PolarRenderer</code>. If you intend to have more than one renderer for your own grid you should consider having such a class as well, so it can serve as a common basis for concrete renderers.</p>
<p >A renderer has to implement the abstract methods <code>CountLines</code>, <code>ComputeLines</code> and <code>GridHasChanged</code>. The first one counts how many lines need to be allocated, the second one actually computes the lines and stores them in the array that has been provided by the base class, and the third one in used to determine whether the rendering system can reuse existing lines.</p>
<p >Your renderer also needs to provide properties to be set by the user, those are entirely up to you.</p>
<p >We will look at an example renderer for rectangular grids that can render a set of rectangles given by the lower-left coordinate of each rectangle. The renderer will be simplified and draw shared edges twice in order to keep this example short.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> CustomGridFramework;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_renderers.html">Renderers</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_renderers_1_1_rectangular.html">Rectangular</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_rendering.html">Rendering</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>CustomGridFramework.Renderers.Rectangular {</div>
<div class="line">  [AddComponentMenu(<span class="stringliteral">&quot;Grid Framework/Renderers/Custom/Rectangular/Tiles&quot;</span>)]</div>
<div class="line">  <span class="keyword">public</span> sealed <span class="keyword">class </span>Tiles : RectangularRenderer {</div>
<div class="line">    [SerializeField]</div>
<div class="line">    <span class="keyword">private</span> List&lt;Vector2&gt; _tiles = <span class="keyword">new</span> List&lt;Vector2&gt;();</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">public</span> List&lt;Vector2&gt; Tiles {</div>
<div class="line">      <span class="keyword">get</span> {</div>
<div class="line">        <span class="keywordflow">return</span> _tiles;</div>
<div class="line">      } <span class="keyword">set</span> {</div>
<div class="line">        _tiles = values;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> (<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> z) CountLines() {</div>
<div class="line">      <span class="comment">// Four edges per tile, two per direction, none in Z-direction</span></div>
<div class="line">      var tiles = Tiles.Count;</div>
<div class="line"> </div>
<div class="line">      var xCount = 2 * tiles;</div>
<div class="line">      var yCount = 2 * tiles;</div>
<div class="line">      var zCount = 0;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">return</span> (xCount, yCount, zCount);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span> <span class="keyword">override</span> <span class="keywordtype">void</span> ComputeLines(LineSegment[][] lineSets) {</div>
<div class="line">      var i = 0;</div>
<div class="line">      <span class="keywordflow">foreach</span> (var tile <span class="keywordflow">in</span> Tiles) {</div>
<div class="line">        ComputeTile(tile, lineSets[0], lineSets[1], i);</div>
<div class="line">        i += 2;  <span class="comment">// Every tile adds two lines per dimension</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> ComputeTile(Vector2 tile,</div>
<div class="line">                             lineSegment[] xLines,</div>
<div class="line">                             lineSegment[] yLines, </div>
<div class="line">                             <span class="keywordtype">int</span> i) {</div>
<div class="line">      var x = tile.x;</div>
<div class="line">      var y = tile.y;</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// The four corners of a tile in world-space</span></div>
<div class="line">      var bl = Grid.GridToWorld(<span class="keyword">new</span> Vector3(x,     y    , 0));</div>
<div class="line">      var tl = Grid.GridToWorld(<span class="keyword">new</span> Vector3(x    , y + 1, 0));</div>
<div class="line">      var tr = Grid.GridToWorld(<span class="keyword">new</span> Vector3(x + 1, y + 1, 0));</div>
<div class="line">      var br = Grid.GridToWorld(<span class="keyword">new</span> Vector3(x + 1, y    , 0));</div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Horizontal lines</span></div>
<div class="line">      xLines[i + 0] = <span class="keyword">new</span> LineSegment(bl, br);  <span class="comment">// Every line is made of two points</span></div>
<div class="line">      xLines[i + 1] = <span class="keyword">new</span> LineSegment(tl, tr);  <span class="comment">// The index of the second line is i+1</span></div>
<div class="line"> </div>
<div class="line">      <span class="comment">// Vertical lines</span></div>
<div class="line">      xLines[i + 0] = <span class="keyword">new</span> LineSegment(bl, tl);  <span class="comment">// Every line is made of two points</span></div>
<div class="line">      xLines[i + 1] = <span class="keyword">new</span> LineSegment(br, tr);  <span class="comment">// The index of the second line is i+1</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_grid_framework_1_1_renderers_1_1_rectangular_html"><div class="ttname"><a href="namespace_grid_framework_1_1_renderers_1_1_rectangular.html">GridFramework.Renderers.Rectangular</a></div><div class="ttdef"><b>Definition:</b> Parallelepiped.cs:4</div></div>
<div class="ttc" id="anamespace_grid_framework_1_1_renderers_html"><div class="ttname"><a href="namespace_grid_framework_1_1_renderers.html">GridFramework.Renderers</a></div><div class="ttdef"><b>Definition:</b> GridRenderer.cs:10</div></div>
<div class="ttc" id="anamespace_grid_framework_1_1_rendering_html"><div class="ttname"><a href="namespace_grid_framework_1_1_rendering.html">GridFramework.Rendering</a></div><div class="ttdef"><b>Definition:</b> GlobalMeshBackend.cs:7</div></div>
</div><!-- fragment --><p >Let us go over this code. First we inherit from the <code>RectangularRenderer</code> class, giving us some useful functionality in the process. The parent class implements <code>GridHasChanged</code>, allows us to access the grid the renderer belongs to, and updates the points when the grid changes. Otherwise we would have to implement these things on our own.</p>
<p >We have a member variable and a property for our tiles, which will be stored as grid-space coordinates. We will ignore the Z-axis, so all our tiles are stored as <code>Vector2</code>.</p>
<p >Next we have to implement the abstract methods from <code>GridRenderer</code>. <code>CountLines</code> is simple, the number of lines is two per axis per tile, except for the Z-lines which we do not draw. <code>ComputeLines</code> loops over the tiles and computes the end points for every tile individually. We keep track of an index variable that tells us where in the list of lines to write to. Finally, the actual computation follows. For every tile we compute its four corners and then assign them as end points of the four lines.</p>
<h1>Writing your own rendering backends</h1>
<p >This is covered in the chapter about <a class="el" href="rendering.html">Drawing and rendering a Grid</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Oct 31 2021 14:33:21 for Grid Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png.txt" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
