<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<title>Grid Framework: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js.txt"></script>
<script type="text/javascript" src="dynsections.js.txt"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js.txt"></script>
<script type="text/javascript" src="navtreedata.js.txt"></script>
<script type="text/javascript" src="navtree.js.txt"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js.txt"></script>
<script type="text/javascript" src="search/search.js.txt"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grid Framework
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
   <div id="projectbrief">Easy grid setup and scripting for Unity 3D</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js.txt"></script>
<script type="text/javascript" src="menu.js.txt"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('overview.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Overview </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_grid_framework_Assets_com_hiphish_grid_framework_README"></a></p>
<h1>Preface</h1>
<p >Thank you for choosing Grid Framework for Unity3D. My goal was to create an easy to use setup where the users only needs to say what kind of grid they want and let the computer do all the math.</p>
<p >This package provides you with new grid components (subclasses of <code>BaseGrid</code>) which can be added to any <code>GameObject</code> in the scene, <code>GridRenderer</code> components for displaying grids, lots of functions to use with the grids and an editor panel for aligning and scaling objects in your scene. Every grid is three-dimensional and infinite in size. You can draw your grids in the editor using gizmos, render them at runtime and even use Grid Framework along with <a href="http://starscenesoftware.com/vectrosity.html">Vectrosity</a> and <a href="https://hutonggames.com/">Playmaker</a> if you have a license for them.</p>
<p >By buying this package you support further development and you are entitled to all future upgrades for free.</p>
<p >Alejandro "HiPhish" Sanchez</p>
<h2>Reading this documentation</h2>
<p >The full user manual and scripting reference is available in HTML format from within Unity3D's "Help" menu under "Grid Framework Documentation". The documentation consists of two parts: the user manual and the API reference. Use the navigation panel in the left-hand side to browse the manual topics and use the search bar in to top right-hand corner to quickly find the reference for classes and methods you want to use.</p>
<h1>Setup</h1>
<p >Nothing special is needed if you get Grid Framework from the Unity Asset Store. All features of Grid Framework, including the documentation, can be accessed through the menu bar, see the <a class="el" href="starting.html">Getting Started</a> page for more information, there is no reason to attach scripts manually.</p>
<h1>What is included</h1>
<p >The package contains one main directory with further sub-directories and files:</p>
<ul>
<li><code>Editor</code>: editor extensions</li>
<li><code>Runtime</code>: The core of Grid Framework</li>
<li><code>Documentation</code>: This file and the complete user manual</li>
<li><code>CHANGELOG.md</code>: Changelog, also accessible from the manual</li>
<li><code>README.md</code>: Readme file, also accessible from the manual</li>
</ul>
<p >The directories contain the source files of Grid Framework and are required for working. Please do not modify them directly or your changes will be overwritten when updating. It is better to write your own grids, renderers, rendering backends and extension methods instead, that way your custom code remains compatible with all future updates.</p>
<p >Playable samples are provided as a separate download, see below. Why not include them? Unity would treat the scenes, scripts, materials and textures as part of your project's assets. I was to avoid spamming your project, but unfortunately the only solution to the problem is to ship the samples separately.</p>
<h2>Extra content</h2>
<p >There are two additional packages available as as public Git repositories:</p>
<ul>
<li><a href="https://gitlab.com/HiPhish/grid-framework-samples/">Playable samples</a></li>
<li><a href="https://gitlab.com/hiphish/grid-framework-align-panel/">Grid align panel</a></li>
<li><a href="https://gitlab.com/HiPhish/grid-framework-vectrosity">Vectrosity support</a></li>
<li><a href="https://gitlab.com/HiPhish/grid-framework-playmaker">Playmaker actions</a></li>
</ul>
<p >These upgrades are free of charge; they are not included in the main distribution as to not bloat the packages size for users who do not need them, and to prevent compilation errors for users who do not have the extra dependencies.</p>
<p >Please refer to the official <a href="https://docs.unity3d.com/Manual/upm-git.html">Unity manual</a> for information on how to add Git dependencies to your project. Every release has its own Git tag, so I recommend targeting a fixed release of each package. The initial tag is always <code>v3.0.0</code>, subsequent tags follow <a href="https://semver.org/">semantic versioning</a>.</p>
<h1>Hello Grid Framework</h1>
<p >Let us create our first grid and perform some basic scripting on it.</p>
<h2>Setting up and displaying a grid</h2>
<p >Import Grid Framework and create a new scene. From Unity's menu select <em>GameObject</em> → <em>3D Object</em> → <em>Grid</em> → <em>Rectangular</em>. A new object will appear in our scene with two components attached to it. If you do not see the grid lines in scene view you will have to turn on gizmos display.</p>
<ul>
<li><code>RectGrid</code> is the class of the grid, in this case a rectangular grid</li>
<li><code>Parallelepiped</code> is the class of the renderer which is what lets us see the grid</li>
</ul>
<p >There are different types of grids, and the grid class (subclass of <code><a class="el" href="class_grid_framework_1_1_grids_1_1_base_grid.html" title="Abstract base class for all Grid Framework grids.">GridFramework.Grids.BaseGrid</a></code>) determines which type it is. In our case we have a rectangular grid which has spacing (how far apart the lines are) and shearing (the angle between lines). Try tweaking these properties, you will see the grid getting updated live.</p>
<p >There is a problem however: grids are infinitely large, but we only want to show a finite slice. This is where the grid renderers (subclasses of <code><a class="el" href="class_grid_framework_1_1_renderers_1_1_grid_renderer.html" title="Abstract base class for all grid renderers.">GridFramework.Renderers.GridRenderer</a></code>) come in: The renderer lets us choose how much of the grid we want to show. Rectangular grids come with only one renderer (<code><a class="el" href="class_grid_framework_1_1_renderers_1_1_rectangular_1_1_parallelepiped.html" title="Parallelepiped shape of a rect grid.">GridFramework.Renderers.Rectangular.Parallelepiped</a></code>), but we can write our own renderers if we want to. We can attach multiple renderers to the same grid if we wish to render multiple slices of it.</p>
<p >Position the grid at the origin of the world if it is not yet, and enter play mode. You will not be able to see the grid in the game unless you have gizmos turned on. In order to actually see the grid in the finished game we have to render it using Unity's rendering facilities. There are a number of rendering backends available, but for now we will keep it simple. Select the grid object, and then from Unity's menu choose <em>Component</em> → <em>Grid Framework</em> → <em>Rendering</em> → <em>Local mesh rendering backend</em>. This will attach three new components to the object:</p>
<ul>
<li><code>MeshFilter</code> (from Unity)</li>
<li><code>MeshRenderer</code> (from Unity)</li>
<li><code>LocalMeshBackend</code> (the backend)</li>
</ul>
<p >When you enter play mode now you should see the grid in your game. Since the grid is being rendered using a regular mesh (with <code>Lines</code> topology) you can affect its appearance by assigning a material to the mesh filter. Your Unity installation should come with some basic default materials for you to try out.</p>
<h2>Scripting a grid</h2>
<p >Now that we can place a grid in the scene, adjust its properties and display it, it is time to actually write some code with it. Create a new script, let's call it <code>HellGrid.cs</code>. The script will be simple: it takes the player's mouse cursor position and snaps it to the nearest vertex of the grid, then draws a little sphere at that position. Make sure you have gizmos turned on in play mode and that your main camera is set to orthographic.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> UnityEngine;</div>
<div class="line"><span class="keyword">using</span> UnityEditor;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_grids.html">Grids</a>;  <span class="comment">// All grids reside in this namespace</span></div>
<div class="line"> </div>
<div class="line">[RequireComponent(typeof(RectGrid))]</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>HelloGrid : MonoBehaviour {</div>
<div class="line">    <span class="keyword">private</span> RectGrid grid;  <span class="comment">// The grid for our logic</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> Start() {</div>
<div class="line">        grid = GetComponent&lt;RectGrid&gt;();  <span class="comment">// Aquire grid reference</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> OnDrawGizmos() {</div>
<div class="line">        <span class="keywordflow">if</span> (!EditorApplication.isPlaying)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        var input = GetWorldInput();</div>
<div class="line">        var snappedPoint = SnapToGrid(input);</div>
<div class="line">        Gizmos.DrawSphere(snappedPoint, 0.3f);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> Vector3 SnapToGrid(Vector3 point) {</div>
<div class="line">        <span class="comment">// Using Grid Framework to perform the calculation</span></div>
<div class="line">        var gridPoint = grid.WorldToGrid(point);</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0; i &lt; 3; ++i) {</div>
<div class="line">            gridPoint[i] = Mathf.Round(gridPoint[i]);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> grid.GridToWorld(gridPoint);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> Vector3 GetWorldInput() {</div>
<div class="line">        <span class="comment">// Regular Unity code</span></div>
<div class="line">        var result = Camera.main.ScreenToWorldPoint(Input.mousePosition);</div>
<div class="line">        result.z = 0;</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_grid_framework_1_1_grids_html"><div class="ttname"><a href="namespace_grid_framework_1_1_grids.html">GridFramework.Grids</a></div><div class="ttdef"><b>Definition:</b> BaseGrid.cs:7</div></div>
<div class="ttc" id="anamespace_grid_framework_html"><div class="ttname"><a href="namespace_grid_framework.html">GridFramework</a></div><div class="ttdef"><b>Definition:</b> HexGridEditor.cs:5</div></div>
</div><!-- fragment --><p >The <code>GetWorldInput</code> method simply converts from screen coordinates to grid coordinates, it only works if the camera is set to orthographic. The <code>SnapToGrid</code> method shows a common pattern:</p>
<ul>
<li>Take some point in world coordinates</li>
<li>Convert it to grid coordinates</li>
<li>Perform your logic in grid space (in this case we round all coordinates to the nearest integer)</li>
<li>Convert back to world coordinates so Unity can understand the result</li>
</ul>
<p >You might have noticed that the sphere can also go beyond the visible area of the grid because grids are infinitely large. Let's use the renderer to limit the sphere to the visible slice of the grid.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> UnityEngine;</div>
<div class="line"><span class="keyword">using</span> UnityEditor;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_grids.html">Grids</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code hl_namespace" href="namespace_grid_framework.html">GridFramework</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_renderers.html">Renderers</a>.<a class="code hl_namespace" href="namespace_grid_framework_1_1_renderers_1_1_rectangular.html">Rectangular</a>;  <span class="comment">// NEW</span></div>
<div class="line"> </div>
<div class="line">[RequireComponent(typeof(RectGrid))]  <span class="comment">// NEW</span></div>
<div class="line">[RequireComponent(typeof(Parallelepiped))]</div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>HelloGrid : MonoBehaviour {</div>
<div class="line">    <span class="keyword">private</span> RectGrid grid;</div>
<div class="line">    <span class="keyword">private</span> Parallelepiped parallelepiped;  <span class="comment">// NEW</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> Start() {</div>
<div class="line">        grid = GetComponent&lt;RectGrid&gt;();</div>
<div class="line">        parallelepiped = GetComponent&lt;Parallelepiped&gt;();  <span class="comment">// NEW</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">void</span> OnDrawGizmos() {</div>
<div class="line">        <span class="keywordflow">if</span> (!EditorApplication.isPlaying)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        var input = GetWorldInput();</div>
<div class="line">        var snappedPoint = SnapToGrid(input);</div>
<div class="line">        Gizmos.DrawSphere(snappedPoint, 0.3f);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> Vector3 GetWorldInput() {</div>
<div class="line">        var result = Camera.main.ScreenToWorldPoint(Input.mousePosition);</div>
<div class="line">        result.z = 0;</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span> Vector3 SnapToGrid(Vector3 point) {</div>
<div class="line">        var gridPoint = grid.WorldToGrid(point);</div>
<div class="line">        <span class="keywordflow">for</span> (var i = 0; i &lt; 3; ++i) {</div>
<div class="line">            <span class="comment">// ALTERED</span></div>
<div class="line">            var min = parallelepiped.From[i];</div>
<div class="line">            var max = parallelepiped.To[i];</div>
<div class="line">            gridPoint[i] = Mathf.Clamp(Mathf.Round(gridPoint[i]), min, max);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> grid.GridToWorld(gridPoint);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_grid_framework_1_1_renderers_1_1_rectangular_html"><div class="ttname"><a href="namespace_grid_framework_1_1_renderers_1_1_rectangular.html">GridFramework.Renderers.Rectangular</a></div><div class="ttdef"><b>Definition:</b> Parallelepiped.cs:4</div></div>
<div class="ttc" id="anamespace_grid_framework_1_1_renderers_html"><div class="ttname"><a href="namespace_grid_framework_1_1_renderers.html">GridFramework.Renderers</a></div><div class="ttdef"><b>Definition:</b> GridRenderer.cs:10</div></div>
</div><!-- fragment --><p >If we don't count the boilerplate code we have effectively only changed one line of code in order to limit the value of the result. This is another common pattern: Use the grid to write your logic, and use the renderer to apply constraints to your logic. Using the renderer has the advantage that your logic will always match the grid you see in your game. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Oct 31 2021 14:33:21 for Grid Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png.txt" alt="doxygen"/></a> 1.9.2 </li>
  </ul>
</div>
</body>
</html>
